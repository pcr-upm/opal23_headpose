import math
import torch


class OpalLoss(torch.nn.Module):
    """Opal loss for wide-range Head Pose Estimation.

    This is a 3-piece loss function that uses an L2 loss for small errors, tanh for medium errors and L1 loss for
    large errors.

    https://arxiv.org/abs/2401.05807

    Args:
        epsilon (float): the threshold value to separate the L2 and tanh parts.
        beta (float): the threshold value to separate the tanh and L1 parts.
        sigma (float): value to multiply the tanh loss. It amplifies the gradients generated by this part.
        mu (float): the gradients from the tanh loss resemble a pseudo-gaussian distribution. This parameter specifies
            the 'mean' of this gaussian distribution. Thus, it is recommended to give it a value such that
            :attr:`epsilon` < :attr:`mu` < :attr:`beta`.
        degrees (bool): set to ``True`` (default) to use degrees as the loss metric, or ``False`` to use radians.
            Input parameters :attr:`epsilon`, :attr:`beta` and :attr:`mu` are also interpreted as degrees or radians
            accordingly.
        euler (bool): if set to ``True``, input tensors will be interpreted as Euler angles and will be converted to
            rotation matrices internally. By default, is set to ``False`` and expects rotation matrices as inputs.
        reduction (str, optional): method to reduce the final loss. Can be ``'mean'``, ``'sum'`` or ``'none'``.

    Shape:
        - Input: (B, 3, 3), batch with predicted rotation matrices. If :attr:`euler` is ``True``, then (B, 3).
        - Target: same shape as the input.
        - Output: scalar. If :attr:`reduction` is ``'none'``, then (B).
    """
    def __init__(
        self,
        epsilon: float,
        beta: float,
        sigma: float,
        mu: float,
        degrees: bool = True,
        euler: bool = False,
        reduction: str = 'mean'
    ):
        super().__init__()

        if reduction not in ('mean', 'sum', 'none'):
            raise ValueError(f'Invalid reduction type {reduction}')

        if degrees:
            epsilon = math.radians(epsilon)
            beta = math.radians(beta)
            mu = math.radians(mu)

        self.epsilon = epsilon
        self.beta = beta
        self.sigma = sigma
        self.mu = mu * sigma
        self.tanh_mu = math.tanh(mu)
        self.degrees = degrees
        self.euler = euler
        self.reduction = reduction
        self._init_constants()

    def _init_constants(self):
        # Compute constants to ensure differentiability and continuity
        tanh_beta = math.tanh(self.sigma * self.beta - self.mu)
        tanh_epsilon = math.tanh(self.sigma * self.epsilon - self.mu)
        self.tanh_diff = 1 / (self.sigma * (1 - tanh_beta ** 2) + 1e-8)
        self.l2_diff = (self.tanh_diff * self.sigma * (1 - tanh_epsilon ** 2)) / (2 * self.epsilon + 1e-8)
        self.tanh_cont = self.l2_diff * self.epsilon ** 2 - self.tanh_diff * (tanh_epsilon + self.tanh_mu)
        self.l1_cont = self.tanh_diff * (tanh_beta + self.tanh_mu) + self.tanh_cont - self.beta

    def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:
        if self.euler:
            input = euler_to_rotation_matrix(input)
            target = euler_to_rotation_matrix(target)

        geo_dist = geodesic_distance(input, target)

        loss_l2 = self.l2_diff * geo_dist ** 2
        loss_tanh = self.tanh_diff * (torch.tanh(self.sigma * geo_dist - self.mu) + self.tanh_mu) + self.tanh_cont
        loss_l1 = geo_dist + self.l1_cont

        mask_l2 = geo_dist < self.epsilon
        mask_tanh = (geo_dist >= self.epsilon) & (geo_dist < self.beta)
        mask_l1 = geo_dist >= self.beta

        loss = loss_l2 * mask_l2 + loss_tanh * mask_tanh + loss_l1 * mask_l1

        if self.degrees:
            loss = torch.rad2deg(loss)
        loss = self._reduce_loss(loss)
        return loss

    def _reduce_loss(self, loss: torch.Tensor) -> torch.Tensor:
        if self.reduction == 'mean':
            return loss.mean()
        elif self.reduction == 'sum':
            return loss.sum()
        else:
            return loss


def geodesic_distance(rot_mat_1: torch.Tensor, rot_mat_2: torch.Tensor) -> torch.Tensor:
    """Computes the geodesic distance between two batches of 3x3 rotation matrices.

    Args:
        rot_mat_1 (torch.tensor): rotation matrix batch of shape (..., 3, 3).
        rot_mat_2 (torch.tensor): rotation matrix batch of shape (..., 3, 3).

    Returns:
        torch.tensor: geodesic distance in radians of each pair of rotation matrices
        in the batch.
    """
    m = torch.bmm(rot_mat_1, rot_mat_2.transpose(1, 2))
    cos = (m[:, 0, 0] + m[:, 1, 1] + m[:, 2, 2] - 1) / 2

    # Avoid nan in backprop
    eps = torch.finfo(cos.dtype).eps
    cos = torch.clamp(cos, -1 + eps, 1 - eps)

    # Geodesic angle in radians
    return torch.acos(cos)


def euler_to_rotation_matrix(euler: torch.Tensor):
    # Convert to radians
    rad = torch.deg2rad(euler)
    cy = torch.cos(rad[:, 0])
    sy = torch.sin(rad[:, 0])
    cp = torch.cos(rad[:, 1])
    sp = torch.sin(rad[:, 1])
    cr = torch.cos(rad[:, 2])
    sr = torch.sin(rad[:, 2])

    # Init R matrix tensors
    working_device = None
    if euler.is_cuda:
        working_device = euler.device
    Ry = torch.zeros((euler.shape[0], 3, 3), device=working_device)
    Rp = torch.zeros((euler.shape[0], 3, 3), device=working_device)
    Rr = torch.zeros((euler.shape[0], 3, 3), device=working_device)

    # Yaw
    Ry[:, 0, 0] = cy
    Ry[:, 0, 2] = -sy
    Ry[:, 1, 1] = 1.
    Ry[:, 2, 0] = sy
    Ry[:, 2, 2] = cy

    # Pitch
    Rp[:, 0, 0] = 1.
    Rp[:, 1, 1] = cp
    Rp[:, 1, 2] = sp
    Rp[:, 2, 1] = -sp
    Rp[:, 2, 2] = cp

    # Roll
    Rr[:, 0, 0] = cr
    Rr[:, 0, 1] = sr
    Rr[:, 1, 0] = -sr
    Rr[:, 1, 1] = cr
    Rr[:, 2, 2] = 1.

    return torch.matmul(torch.matmul(Rr, Ry), Rp)
